# My Little Knight

간단한 2D 픽셀 스타일의 로그라이크 생존 게임입니다.

---
## 🎮 게임 플레이 & 특징

- **두 종류의 무기**: 플레이어는 **검**과 **활**을 사용하여 몬스터를 공격할 수 있습니다. 각 무기는 독특한 공격 방식과 애니메이션을 가지고 있습니다.
  - 활 공격은 기본 공격이며 최소 2초의 쿨타임에서 최대 1초까지 공격 쿨타임을 활 아이템 획득으로 줄일 수 있습니다.
  - 검 공격은 10초마다 사용이 가능하며 가까이에 붙은 몬스터들을 넉백 시키며 에너지 탄을 발사해 일직선 상으로 몬스터들에게 데미지를 줍니다. 

- **몬스터 강화**: 게임이 진행될수록 20초마다 몬스터의 능력치 (Normal 몬스터 스폰 수, 체력, 데미지, 이동속도) 가 강화되어 난이도가 점차 상승합니다.
  
- **특정한 상황에 등장하는 강화 몬스터**: 총 세 종류의 몬스터가 등장하며, 일반적으로 스폰되는 Normal 몬스터, Normal 몬스터 셋을 잡으면 스폰되는 Strong 몬스터, 특정 점수를 획득해야 스폰되는 Elite 몬스터.

- **생존에 도움을 주는 각종 아이템**:
  - 활과 검의 공격력 상승 아이템, 체력과 방어력을 회복하는 아이템, 이동속도 증가 아이템이 맵 내에서 랜덤 스폰됩니다.
  - 활 공격 아이템 획득 시 활 공격 쿨타임을 줄여주는 기능의 아이템이 존재합니다.
  - **아이템 스폰 시스템**: 5초마다 맵 내 무작위 위치에 아이템 하나가 스폰되고, 10초마다 무작위 위치에 아이템 랜덤 상자가 스폰됩니다.

- **맵 좌우에서 발사되는 적 발사체**:
  - 시작하면 랜덤한 위치에 스폰되 맵 좌<->우 에서 랜덤으로 생성되는 적 발사체.
  - 몬스터와 같이 20초마다 강화됩니다. 20초마다 데미지, 생성 속도, 발사 속도.

---


##  주요 문제 해결 과정 & 배운 점

<details>
<summary><b>몬스터 물리 충돌 및 플레이어 접근 버그 해결</b></summary>
<br/>


### 문제점

- 몬스터끼리 서로 겹치는 현상 발생
- 몬스터가 플레이어에게 다가가지 못하고, 보이지 않는 벽에 막히는 현상 발생
- 플레이어가 타일맵 밖으로 나가는 현상 발생

### 원인 분석

- **콜라이더 설정 오류**: 몬스터 프리팹에 콜라이더가 하나뿐이라 물리적인 충돌 처리가 부족했습니다. 또한, 플레이어의 자식 오브젝트인 `SwordPoint`의 콜라이더 속성이 잘못 설정되어 몬스터에게 접근하지 못하게 막는 '벽' 역할을 했습니다.
    ![몬스터가 플레이어에게 닿지 못함](https://github.com/trst3385/MyLittleKnight/blob/main/Image/Monster.Bug.gif?raw=true)<br><br><br>
- **다중 역할 충돌**: 플레이어에게 콜라이더가 하나만 있어, 벽에 부딪히는 물리적 충돌과 몬스터와 겹치는 감지 역할을 동시에 수행할 수 없었습니다.

### 해결 과정

1.  **몬스터 프리팹 수정**:
    - `Box Collider 2D`를 추가하여 물리 충돌용과 감지용 콜라이더의 역할을 분리했습니다.
    - 기존 콜라이더는 몬스터 감지용(`Is Trigger` 켬), 새로 추가한 콜라이더는 몬스터 간 물리 충돌용(`Is Trigger` 끔)으로 설정했습니다.
      
2.  **플레이어 콜라이더 역할 분리**:
    - **물리 충돌용 콜라이더**(`Is Trigger` 끔)와 **몬스터 감지용 콜라이더**(`Is Trigger` 켬)를 따로 만들어 각 역할에 맞게 설정했습니다.
      
3.  **레이어 설정**:
    - `Layer Collision Matrix`를 활용하여 플레이어 레이어와 몬스터 레이어의 충돌을 비활성화해 의도하지 않은 물리적 상호작용을 방지했습니다.
      
4.  **`SwordPoint` 수정**:
    - `SwordPoint`의 `Is Trigger`를 `켜짐` 상태로 변경하여, 물리적인 충돌을 일으키지 않고 감지 영역 역할만 하도록 수정했습니다.

### 배운 점

- 유니티의 **콜라이더 역할 분리**와 **`Is Trigger` 속성의 정확한 활용법**을 이해했습니다.
- **Layer Collision Matrix**를 사용하여 복잡한 물리 상호작용을 체계적으로 관리하는 방법을 익혔습니다.
- 하나의 컴포넌트가 여러 역할을 동시에 수행할 때 발생할 수 있는 문제점을 파악하고, 최적화하는 방법을 배웠습니다.


</details>


<details>
<summary><b>플레이어가 몬스터에게 닿았을때 데미지를 받아야 하는 문제 해결 과정</b></summary>
<br/>

### 문제점

- **Layer Collision Matrix 충돌 문제**: 몬스터와 플레이어 간의 충돌을 감지하기 위해 **`Layer Collision Matrix`**를 켰을 때, 의도치 않은 물리적 상호작용이 발생했습니다.
    - **예시**: 플레이어의 이동용 콜라이더와 몬스터의 콜라이더가 겹쳐 플레이어가 **타일맵 경계를 뚫고 나가는 버그**가 발생했습니다.  
- **다중 콜라이더 충돌 문제**: 몬스터의 콜라이더가 '물리 충돌'(몬스터끼리 겹치지 않게)과 '공격 범위'(플레이어에게 닿았을 때)의 두 가지 역할을 동시에 수행해야 했습니다. Layer Collision Matrix를 켜면 이 두 역할이 서로 충돌하여 게임 로직이 꼬였습니다.
    - Layer Collision Matrix에 대한 문제는 다른 문제 해결 과정에도 있었듯이 플레이어와 몬스터의 체크를 하면 다른 문제가 계속 발생하니 체크를 해제한 상태에서 문제를 해결해야 했습니다.
      
### 원인 분석

- **물리적 충돌과 논리적 감지의 혼동**: 기존에는 `Layer Collision Matrix`를 이용해 콜라이더 간의 상호작용을 제어하려 했지만, 이 방식은 물리 엔진에 종속적이라서 논리적인 '접근 감지'와 물리적인 '겹침 방지'를 동시에 처리하기 어려웠습니다.
- **유니티 충돌 시스템의 제약**: 유니티의 물리 충돌 시스템은 한정된 Layer를 통해 복잡한 상호작용을 제어하는 데 한계가 있었습니다. 특히, 이미 다른 용도로 사용 중인 콜라이더들을 억지로 활용하려다 보니 문제가 발생했습니다.

### 해결 과정

1. **접근 감지 로직 분리**: 물리 충돌 시스템 대신 **거리 기반 감지** 로직을 도입했습니다. `FixedUpdate()` 함수에서 몬스터와 플레이어의 거리를 지속적으로 계산하여, 특정 거리(`StopDistance`변수) 이내에 접근했는지 판별했습니다.
2. **데미지 로직 함수화**: 몬스터의 공격 애니메이션 이벤트(`Attack()`)와 별개로, **닿았을 때 데미지를 주는 로직**을 **`ApplyTouchDamage()`** 함수로 분리했습니다.
   * 이 함수는 플레이어의 방어막(`PlayerShield`) 유무를 확인하고, 방어막이 있으면 방어막에, 없으면 체력(`PlayerHealth`)에 데미지를 주는 역할을 수행합니다.
3. **데미지 로직과 애니메이션 분리**: `ProcessMovementAndAttack()` 함수 내에서 **공격 쿨타임(`AttackCooldown`)**을 기준으로 데미지를 주는 로직과 공격 애니메이션을 재생하는 로직을 분리했습니다.
    * `if (canAttack)` 조건문을 추가하여 `AttackCooldown`이 지날 때마다 **`ApplyTouchDamage()`** 함수를 호출했습니다.
    * `animator.SetBool("Attack", true)`는 닿았을 때 데미지 로직과 별개로 일반적인 몬스터가 정지 거리에 있을 때 공격모션으로 데미지를 줄때 실행되도록 했습니다.
4. **코드 리팩토링**: 데미지가 이중으로 들어가는 버그를 해결하기 위해, `FixedUpdate()` 함수에서 `ApplyTouchDamage()`를 직접 호출하는 코드를 제거하고, 오직 `ProcessMovementAndAttack()` 함수 내에서만 호출되도록 수정했습니다.


### 배운 점

1. **게임 로직의 중요성**: 모든 문제를 유니티의 물리 시스템(Collider)에만 의존할 필요가 없다는 것을 깨달았습니다. 거리 계산`Vector` 이나 타이머`Time.time` 와 같은 순수한 게임 로직을 활용하는 것이 더 유연하고 효과적일 수 있음을 배웠습니다.
2. **관심사 분리(Separation of Concerns)**: 복잡한 기능을 `ApplyTouchDamage()` 함수와 같이 기능별로 나누는 모듈화의 중요성을 이해했습니다. 이는 코드의 가독성과 유지보수성을 크게 향상시켰습니다.
3. **도구 활용**: 혼자서 해결하기 어려운 문제는 **AI와 같은 도구**를 활용하여 빠르게 해결하고, 이를 내 것으로 만드는 방법을 익혔습니다. 이는 실무에서도 매우 중요한 역량이라고 생각합니다.
   - AI의 조언을 단순히 받아들이는 것이 아니라, "왜?"라는 질문을 통해 원리를 파악하고 내 지식으로 만드는 과정을 중요하게 여깁니다.
   - 가짜 실력이 아닌 내 실력으로, 당장의 빠른 정답보다 과정을 통한 깨달음이 진짜 실력이라고 믿으며, 이것이 AI를 활용하는 올바른 자세라고 생각합니다.


</details>


<details>
<summary><b>검 공격 로직 및 콜라이더 문제 해결</b></summary>
<br/>

### 문제점

- `OnTriggerEnter2D` 이벤트 방식의 한계: 몬스터가 이미 공격 범위(콜라이더) 안에 있을 경우, 공격이 감지되지 않아 데미지를 줄 수 없었습니다.
- **콜라이더 역할 충돌**: 검 공격용 콜라이더가 물리적 충돌 역할까지 수행하면서, 몬스터가 플레이어에게 접근하지 못하게 막는 '벽' 역할을 했습니다.


### 원인 분석

- `OnTriggerEnter2D` 이벤트는 콜라이더에 **'처음 진입하는 순간'**에만 발생합니다. 따라서 몬스터가 이미 콜라이더 내부에 있는 상태에서는 공격 이벤트가 호출되지 않아 데미지를 줄 수 없었습니다.

### 해결 과정

1.  **공격 방식 변경**: `OnTriggerEnter2D` 이벤트 방식 대신, 검을 휘두르는 **애니메이션 이벤트**에서 `Physics2D.OverlapBoxAll` 함수를 직접 호출하는 방식으로 변경했습니다.  
    - **OnTriggerEnter2D = 콜라이더에 '진입' 하는 순간 한 번만 작동, OverlapBoxAll = 특정 순간에 '스냅샷' 을 찍듯 범위 안의 모든 콜라이더들을 감지. 그래서 검이 휘둘러지는 그 순간에 공격 범위에 있는 모든 적에게 데미지를 줄 수 있다** 
2.  **공격 대상 감지**: `Physics2D.OverlapBoxAll`을 사용하여 특정 순간(애니메이션 프레임)에 검의 공격 범위 내에 있는 **모든** `Collider2D`를 감지하도록 구현했습니다.
3.  **적 필터링**:  public string EnemyTag = "Enemy" 변수를 선언,  감지된 콜라이더들 중 `hitCollider.CompareTag(EnemyTag)`를 통해 **"Enemy" 태그** 가 붙은 오브젝트만 공격 대상으로 필터링하여 데미지를 적용했습니다.
4.  **넉백 로직 구현**: 적에게 데미지를 주는 동시에, **넉백 벡터**를 계산하여 적이 공격 방향으로 밀려나도록 `TakeKnockback` 함수를 호출했습니다.

### 배운 점

- **유니티 API 선택의 중요성**: 상황에 따라 `OnTriggerEnter`와 같은 이벤트 방식보다 `Physics2D.OverlapBoxAll`과 같이 직접 물리 감지를 수행하는 방식이 더 효율적일 수 있다는 것을 깨달았습니다.
- **코드 직관성 및 효율성**: `Tag`를 활용한 필터링 방식은 코드 가독성을 높이고, 특정 대상만을 효율적으로 공격하는 데 매우 효과적이었습니다.


</details>


<details>
<summary><b>몬스터의 플레이어 추적 및 공격 위치 문제</b></summary>
<br/>


### 문제점

- 몬스터가 플레이어를 추적하고 공격할 때, 플레이어의 몸통 중앙에 도착한 후 공격을 해야 했으나, 몬스터가 플레이어의 머리 위에서 공격하는 시각적 문제가 발생. 몬스터 크기가 클수록 더욱 위에서 멈추고 공격을 하던 문제 발생.

### 원인 분석

- **피벗(Pivot)과 콜라이더(Collider)의 불일치**: 다운받은 에셋의 크기를 조절하면서 몬스터와 플레이어의 피벗 위치와 콜라이더의 중심이 정확히 일치하지 않아 발생한 문제. 몬스터가 플레이어의 피벗(transform.position)을 추적하면서 몸통이 아닌 머리 위에서 멈추게 되었음.
- **거리 기반 공격 로직**: 몬스터의 공격이 시각적으로는 닿지 않았지만, 코드상으로는 이미 공격 범위 안에 들어와 있다고 판단하여 데미지를 입히는 논리적 오류가 있었음.

### 해결 과정

1.  **플레이어의 몸통 중앙 위치를 반환하는 함수 구현**:
   - `Player` 스크립트에 `GetCenterPosition()` 함수를 추가하고, 플레이어의 `BoxCollider2D`의 `bounds.center`를 반환하도록 구현.
     
2.  **몬스터 추적 목표 수정**:
   - `Enemy.cs` 스크립트에서 플레이어의 `transform.position` 대신 `playerScript.GetCenterPosition()`을 사용하여 몬스터의 추적 목표 위치를 플레이어의 몸통 중앙으로 변경.
     
3.  **수동 위치 보정**:
   - `Enemy.cs`에 `playerTargetOffsetY` 변수를 추가하여 몬스터의 Y축 위치를 수동으로 인스펙터에서 조절할 수 있게 함.
   - `FixedUpdate` 함수에서(물리 계산 로직이 Update보다 더욱 효과적) `playerCenterPosition.y += playerTargetOffsetY;` 코드를 통해 몬스터가 플레이어의 몸통 중앙보다 약간 아래 지점을 목표로 삼도록 수정.

### 배운 점

- **피벗(Pivot)과 콜라이더(Collider)**의 정확한 역할을 이해했습니다. 시각적인 모습뿐만 아니라, 물리적 충돌 영역과 오브젝트의 기준점을 따로 관리해야 함을 배웠습니다.
- **`bounds.center`**와 같은 API를 활용하여 오브젝트의 특정 영역에 대한 정보를 가져오는 방법을 익혔습니다.
- 문제의 근본적인 원인을 파악하고, 그에 맞는 **유연한 논리적인 해결책**을 코드로 구현하는 능력을 키웠습니다.


</details>



##  웅잉

